# Toy3 Compiler

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## Description

**Toy3 Compiler** is an educational compiler for the **Toy3** language, designed to facilitate the learning of fundamental compiler principles. The compiler translates programs written in Toy3 into standard C code, which can be compiled with GCC or Clang, allowing the creation of native executables.

The project is developed in Java and is based on well-established tools like **JFlex** (for lexical analysis) and **JavaCup** (for syntactic analysis), integrating semantic analysis and code generation techniques using the Visitor pattern.

---

## Main Features

- **Lexical Analysis**: the lexer transforms source code into meaningful tokens.
- **Syntax Analysis**: the parser builds an Abstract Syntax Tree (AST).
- **Semantic Analysis**: scope management, type checking, inference, and parameter verification.
- **C Code Generation**: the AST is translated into readable and compilable C code.
- Support for classic constructs: functions, variables, references, control commands (if, while), blocks.
- 

---

## Project Structure

```
toy3_compiler/
├── README.md                 # Project documentation
├── pom.xml                  # Maven configuration for build and execution
├── src/                     # Java source code
│   ├── main/                # Main code
│   └── test/                # Java tests
├── srcjflexcup/             # Lexer and Parser specification files
│   ├── *.flex               # Lexical definitions (lexer)
│   └── *.cup                # Syntactic definitions (parser)
├── target/                  # Files generated by Maven (compiled classes)
├── tests/                   # Folders with grouped tests
│   ├── valid1/
│   ├── valid2/
│   ├── valid3/
│   └── valid4/
├── valid1.txt               # Toy3 test files
├── valid2.txt
├── valid3.txt
├── valid4.txt
├── test_files/              # Generated outputs (C code)
│   └── c_out/
└── other files and folders for reports and XML data
```

---

## Prerequisites

- Java JDK 11+  
- Maven 3.6+  
- GCC/Clang (optional, to compile generated C code)  

Make sure `java` and `mvn` are in your PATH.

---

## Installation and Compilation

Clone the repository:

```bash
git clone https://github.com/yourname/toy3_compiler.git
cd toy3_compiler
```

To compile the Java project:

```bash
mvn compile
```

---

## Execution

To compile a single Toy3 file and generate the corresponding C code:

```bash
mvn exec:java -Dexec.mainClass="main.Main" -Dexec.args="tests/valid1/valid1.txt"
```

The resulting `.c` file will be saved in `test_files/c_out`.

---

## Script to Compile Multiple Tests

To automatically compile the `valid1`, `valid2`, `valid3`, and `valid4` tests, use the bash script:

```bash
#!/bin/bash

OUTPUT_DIR="test_files/c_out"
mkdir -p "$OUTPUT_DIR"

TESTS=(
  "tests/valid1/valid1.txt"
  "tests/valid2/valid2.txt"
  "tests/valid3/valid3.txt"
  "tests/valid4/valid4.txt"
)

mvn compile || { echo "Compilation error!"; exit 1; }

for testfile in "${TESTS[@]}"
do
  echo "Compiling $testfile..."
  mvn exec:java -Dexec.mainClass="main.Main" -Dexec.args="$testfile" || echo "Error on $testfile"
done

echo "Generation completed."
```

Save it as `compile_tests.sh`, make it executable (`chmod +x compile_tests.sh`), and run it with `./compile_tests.sh`.

---

## How It Works Internally

### 1. Lexical Analysis

The lexer is generated with **JFlex** from the `lexical_specification_toy3.flex` file. It transforms the source text into tokens (keywords, identifiers, numbers, operators, separators).

### 2. Syntax Analysis

The parser is generated with **JavaCup** using `grammar_specification_toy3.cup`. It produces an Abstract Syntax Tree (AST) representing the grammatical structure of the program.

### 3. Semantic Analysis

Using **visitors**, the AST is traversed to:

- Manage scope environments and symbol tables.
- Check variable declarations and usage.
- Infer and check types.
- Validate reference parameters.

### 4. C Code Generation

An additional visitor traverses the AST and translates each node into equivalent C code, with particular attention to preserving semantics (e.g., reference variables translated as pointers).

---

## Contributing

Contributions, bug reports, and feature requests are welcome!  
Open an issue or a pull request.

---

## License

This project is released under the MIT license — see the [LICENSE](LICENSE) file for details.

---

## Contact

For questions or support, contact me at: `your_email@example.com`
